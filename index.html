<!DOCTYPE html>
<html>
<body style="margin:0; overflow:hidden; background:#000; font-family: monospace;">
<canvas id="c"></canvas>
<script>
const x = c.getContext("2d");
let w = c.width = innerWidth, h = c.height = innerHeight;
let t = 0, dist = 0, speed = 25, gameOver = false, keys = {}, objects = [], stars = [];

let hiScore = localStorage.getItem("roadHi") || 0;
for(let i=0; i<120; i++) stars.push({x: Math.random()*w, y: Math.random()*h*0.5, s: Math.random()*2});

const spawnWorld = () => {
    if (gameOver) return;
    if (t % 15 === 0) objects.push({ type: 'tree', x: Math.random() > 0.5 ? 750 : -750, z: 5000 });
    if (t % 45 === 0) {
        const lanes = [-220, 0, 220];
        objects.push({ 
            type: 'car', 
            x: lanes[Math.floor(Math.random()*lanes.length)], 
            z: 5000, 
            color: `hsl(${Math.random()*360}, 50%, 40%)` // Opponents are darker/duller
        });
    }
};

// PLAYER CAR: Sleek Sports Car with Spoiler and Neon
const drawPlayerCar = (x2d, y2d, scale) => {
    let sw = 110 * scale, sh = 40 * scale;
    x.save(); x.translate(x2d, y2d);
    
    // Cyan Underglow
    x.shadowBlur = 30; x.shadowColor = "#0ff";
    x.fillStyle = "#0ff"; x.globalAlpha = 0.3;
    x.fillRect(-sw, 0, sw*2, 10);
    x.globalAlpha = 1;

    // Body
    x.fillStyle = "#111"; x.fillRect(-sw, -sh, sw*2, sh); 
    
    // Spoiler
    x.fillStyle = "#0ff"; x.fillRect(-sw, -sh-15, sw*0.2, 15);
    x.fillRect(sw*0.8, -sh-15, sw*0.2, 15);
    x.fillRect(-sw, -sh-20, sw*2, 5);

    // Cyan Cabin
    x.fillStyle = "#0cc"; x.beginPath();
    x.moveTo(-sw*0.7, -sh); x.lineTo(sw*0.7, -sh);
    x.lineTo(sw*0.3, -sh*2); x.lineTo(-sw*0.3, -sh*2); x.fill();

    // Red Tail Lights (Bloom)
    x.shadowColor = "#f00"; x.shadowBlur = 20;
    x.fillStyle = "#ff0000";
    x.fillRect(-sw*0.9, -sh*0.8, sw*0.25, sh*0.3);
    x.fillRect(sw*0.65, -sh*0.8, sw*0.25, sh*0.3);
    x.restore();
};

// OPPONENT CAR: Boxy Sedan / Commuter
const drawEnemyCar = (x2d, y2d, scale, color) => {
    let sw = 90 * scale, sh = 50 * scale;
    x.save(); x.translate(x2d, y2d);
    x.shadowBlur = 10; x.shadowColor = color;
    
    // Simple Boxy Body
    x.fillStyle = "#222"; x.fillRect(-sw, -sh, sw*2, sh);
    
    // High Roof
    x.fillStyle = color; x.fillRect(-sw*0.6, -sh*1.8, sw*1.2, sh*0.8);
    
    // White Headlights (Back view, so they look like white markers)
    x.shadowBlur = 5; x.fillStyle = "#ddd";
    x.fillRect(-sw*0.8, -sh*0.7, sw*0.2, sh*0.2);
    x.fillRect(sw*0.6, -sh*0.7, sw*0.2, sh*0.2);
    x.restore();
};

const drawTree = (x2d, y2d, scale) => {
    let ts = 180 * scale;
    x.fillStyle = "#0a0500"; x.fillRect(x2d - ts/8, y2d - ts, ts/4, ts);
    x.fillStyle = "#041a04"; x.beginPath();
    x.moveTo(x2d - ts, y2d - ts*0.8); x.lineTo(x2d + ts, y2d - ts*0.8); x.lineTo(x2d, y2d - ts*3); x.fill();
};

const loop = () => {
    x.fillStyle = "#000208"; x.fillRect(0, 0, w, h);
    x.fillStyle = "#fff"; stars.forEach(s => x.fillRect(s.x, s.y, s.s, s.s));

    let horizon = h * 0.52;
    x.fillStyle = "#0d0d0d"; // Road
    x.beginPath(); x.moveTo(w/2-30, horizon); x.lineTo(w/2+30, horizon); x.lineTo(w*2, h); x.lineTo(-w, h); x.fill();

    // Side Rails
    x.strokeStyle = "#00f"; x.lineWidth = 2;
    for(let i=0; i<15; i++) {
        let z = ((t * speed + i * 400) % 4000);
        let scale = 400 / (400 + (4000 - z));
        let y = horizon + (h - horizon) * scale;
        x.globalAlpha = scale;
        x.strokeRect(w/2 - 500 * scale, y, 1000 * scale, 1);
    }
    x.globalAlpha = 1;

    if (!gameOver) {
        if (keys.a || keys.ArrowLeft) dist -= 10;
        if (keys.d || keys.ArrowRight) dist += 10;
        t++; spawnWorld();
        speed += 0.002;
    }

    objects.sort((a, b) => b.z - a.z);
    objects.forEach((obj, i) => {
        obj.z -= speed;
        let scale = 400 / (400 + obj.z);
        let x2d = (obj.x - dist) * scale + w/2;
        let y2d = horizon + (h - horizon) * scale;

        if (obj.z < -400) { objects.splice(i, 1); return; }
        
        if (obj.type === 'tree') drawTree(x2d, y2d, scale);
        else {
            if (obj.z < 100 && obj.z > -50 && Math.abs(obj.x - dist) < 140) {
                gameOver = true;
                if (t > hiScore) { hiScore = t; localStorage.setItem("roadHi", hiScore); }
            }
            if (obj.z > 0) drawEnemyCar(x2d, y2d, scale, obj.color);
        }
    });

    drawPlayerCar(w/2, h * 0.9, 1);

    // UI
    x.shadowBlur = 10; x.shadowColor = "#0ff"; x.fillStyle = "#0ff"; x.font = "bold 20px monospace";
    x.fillText(`SCORE: ${t}`, 30, 40);
    x.fillStyle = "#f0f"; x.fillText(`BEST:  ${hiScore}`, 30, 70);

    if (gameOver) {
        x.fillStyle = "rgba(0,0,0,0.85)"; x.fillRect(0,0,w,h);
        x.fillStyle = "#fff"; x.textAlign = "center";
        x.font = "50px monospace"; x.fillText(t >= hiScore && t > 0 ? "NEW RECORD!" : "WRECKED", w/2, h/2);
        x.fillText("PRESS R TO REBOOT", w/2, h/2+80);
    }
    requestAnimationFrame(loop);
};

onkeydown = e => { keys[e.key] = 1; if(e.key=='r' && gameOver) location.reload(); };
onkeyup = e => keys[e.key] = 0;
loop();
</script>
</body>
</html>